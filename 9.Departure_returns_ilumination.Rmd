---
title: "Departures/returns by individuals"
author: "Camila Calderon"
date: "2024-04-26"
output: html_document
---

### Load packages

```{r}
pacman::p_load(dplyr, lubridate, ggplot2, data.table, plyr, raster, ggpubr, emmeans, tidyverse, factoextra, lme4, hms)
```

### Load data

```{r setup, include=FALSE}
load(file="~/ownCloud/PhDLife/P.hastatus/Thesis/Paper3/data/bocas_2022-2023HMMbehaviors.RData")
```

### Extract foraging points from data set of la Gruta colony in February - colony 1

Here I am adding a variable that counts the length of consecutive commuting and foraging points. This will be used to filter only foraging points that contains 4 or more points in row. I will also filter commuting points that have 5 or more points in a row.

```{r, results=FALSE}
hast_df <- bocas
hast_df$n <- NA
r <- rle(hast_df$behav)

for(i in 1:length(r$lengths)){
  #if(r$values[i] == "commuting"){
      start <- {}
      end <- {}
      try(start <- sum(r$lengths[1:(i-1)])+1)
      if(i == 1) start <- 1
      end <- sum(r$lengths[1:i])

      hast_df$n[start:end] <- r$lengths[i]
}

# data frame with only tracking from February
bats_feb <- hast_df %>%
 filter(date > "2022-01-01" & date < "2022-03-01")%>%
  filter(tag_local_identifier!= "0C506E35_G") 

# This individual has inly two nights of tracking, we still used this data tag_local_identifier!="53506935_G" & tag_local_identifier!= "22507B4E_D" & tag_local_identifier!= "38500437_D" & tag_local_identifier!="38506D37_D"

# split data frame by ID
bats_feb_split <- split(bats_feb, bats_feb$ID)

# foraging spots which >= 4 foraging points and stays longer than 8 minutes
foragingdata <- lapply(bats_feb_split, function(x){
  filter(x, c(behav=="foraging" & n>=4 & location_long<=-82.35))
})

# for some reason one individual has no more than 3 foraging in a row, I had to add it manually
x <- data.frame(bats_feb_split[["39500E37_D_2022-02-04"]] %>%
  filter(behav=="foraging"& location_long<=-82.35))

foragingdata[["39500E37_D_2022-02-04"]] <- x

# take first foraging point for each ID
firstforaging <- rbindlist(lapply(foragingdata, function(x){
  dplyr::slice_head(x, n=1)
}))

# take the last foraging point for each ID
lastforaging <- rbindlist(lapply(foragingdata, function(x){
  slice(x, which.max(1:n()))
}))

idday <- unique(bats_feb$ID)
```

### Plot foraging locations selected to verify filtering

```{r}
pdf("~/ownCloud/PhDLife/P.hastatus/Thesis/Paper3/analysis/results/foragingearly2022_check.pdf")
for (i in 1:length(idday)){
  day_phast <- bats_feb[bats_feb$ID == idday[i],]
  day_phast2 <- firstforaging[firstforaging$ID == idday[i],]
    #create plot
   plot(day_phast$location_long, day_phast$location_lat, main=idday[i])
points(day_phast2$location_long, day_phast2$location_lat, col="red")
}
while (!is.null(dev.list()))  
  dev.off()
```

### Select commuting paths to extract departure times
```{r}
# filter only commuting with 5 or more points in a row
bats_commufeb <- bats_feb  %>%  
  filter(behav=="commuting" & n>=5)

ggplot(aes(x=location_long, y=location_lat, col=tag_local_identifier), data=bats_commufeb) + geom_point()

# take the first row of each id date in the commuting tracks
commu_feb_dep <- bats_commufeb %>%
  group_by(ID_batday) %>%
  slice(which.min(1:n()))

# remove 2D507235_G_2022−01−31
commu_feb_dep <- commu_feb_dep[commu_feb_dep$ID!="2D507235_G_2022-01-31",]

# add departure lat, long, timestamp and group id to the data frame
commu_feb_dep$lat_foraging <-  firstforaging$location_lat
commu_feb_dep$long_foraging <-  firstforaging$location_long
commu_feb_dep$timestamp_foraging <-  firstforaging$timestamp
commu_feb_dep$cave_group <-  firstforaging$group_id

#add time to the data frame
commu_feb_dep$time <- format(commu_feb_dep$timestamp, format = "%H:%M:%S")
commu_feb_dep$time <- as.POSIXct(commu_feb_dep$time, format = "%H:%M:%S", tz="UTC")
commu_feb_dep$time_num <-  as.numeric(as_hms(commu_feb_dep$time)) #time in a numeric value


```

### Extract return times

```{r}
# calculating return foraging locations
commu_feb_ret <- bats_commufeb %>%
  group_by(ID) %>%
  slice(which.max(1:n()))

# remove 2D507235_G_2022−01−31
commu_feb_ret <- commu_feb_ret[commu_feb_ret$ID!="2D507235_G_2022-01-31",]

# add return lat, long, timestamp and group id to the data frame
commu_feb_ret$lat_foraging <-  lastforaging$location_lat
commu_feb_ret$long_foraging <-  lastforaging$location_long
commu_feb_ret$timestamp_foraging <-  lastforaging$timestamp
commu_feb_ret$cave_group <-  lastforaging$group_id

#add time to the data frame
commu_feb_ret$time <- format(as.POSIXct(commu_feb_ret$timestamp), format = "%H:%M:%S")
commu_feb_ret$time <- as.POSIXct(commu_feb_ret$time, format = "%H:%M:%S", tz="UTC")
commu_feb_ret$time_num <-  as.numeric(as_hms(commu_feb_ret$time))


write.csv(commu_feb_ret, file="/Users/ccalderon/ownCloud/PhDLife/P.hastatus/Thesis/Paper3/data/returns_feb.csv")
```

#### Look at the similarity of the departures in within and between individuals 2022

```{r}
#split data frame by id
commu_feb_dep_id <- split(commu_feb_dep, f=commu_feb_dep$tag_local_identifier)

#Calculate departure time difference by idday
dep_diff <-  rbindlist(lapply(commu_feb_dep_id, FUN=function(t){
  combi <- t(combn(as.character(t$date), 2)) # all unique pairwise combinations of individuals
  bat <- unique(t$tag_local_identifier)# UTC time
  combi <- data.frame(date1=combi[,1], date2=combi[,2], bat=bat, stringsAsFactors=F) # set up a new data frame
  combi <- combi[combi$date1!=combi$date2,]# just in case that a single bat has two readings for the same timestamp
  
  combi$Deptimediff <- unlist(lapply(1:nrow(combi), function(i){ # calculate time difference between all pairs (in meters!!)
    pos.time1<- t[t$date==combi$date1[i], c('time')] # location for first bat
    pos.time2 <- t[t$date==combi$date2[i], 'time'] # location for second bat
    return(difftime(pos.time1$time, pos.time2$time, units="mins"))})) # geographic distance between bats (in meters)
  return(combi)
  }))

#convert negative to positive values
dep_diff$Deptimediff <- abs(dep_diff$Deptimediff)
dep_diff$bat1 <- dep_diff$bat
dep_diff$bat2 <- dep_diff$bat
dep_diff$sameid <- "yes"
dep_diff$date <- paste(dep_diff$date1, dep_diff$date2, sep="_")
#subset dataframe
dep_diff_sub <- dep_diff[,c("bat1","bat2","date1","date2","sameid","Deptimediff")]

# split by day
commu_feb_dep_day <- split(commu_feb_dep, f=commu_feb_dep$date)

dep_diff_day <-  rbindlist(lapply(commu_feb_dep_day[1:11], FUN=function(t){
  combi <- t(combn(t$tag_local_identifier, 2)) # all unique pairwise combinations of individuals
  date <- unique(t$date)# UTC time
  combi <- data.frame(bat1=combi[,1], bat2=combi[,2], date=date, stringsAsFactors=F) # set up a new data frame
  combi <- combi[combi$bat1!=combi$bat2,]# just in case that a single bat has two readings for the same timestamp
  
  combi$Deptimediff <- unlist(lapply(1:nrow(combi), function(i){ # calculate time difference between all pairs (in meters!!)
    pos.time1<- t[t$tag_local_identifier==combi$bat1[i], 'timestamp'] # location for first bat
    pos.time2 <- t[t$tag_local_identifier==combi$bat2[i], 'timestamp'] # location for second bat
    return(difftime(pos.time1$timestamp, pos.time2$timestamp, units="mins"))})) # geographic distance between bats (in meters)
  return(combi)
  }))

#convert negative to positive values
dep_diff_day$Deptimediff <- abs(dep_diff_day$Deptimediff)

dep_diff_day <- dep_diff_day %>%
  mutate(group1=str_sub(bat1, 10, 10), group2=str_sub(bat2, 10, 10), groups=paste(group1,group2, sep="_"), bat=paste(bat1, bat2, sep="_"))

dep_diff_day$sameid <- "no"
dep_diff_day$date1 <- as.character(dep_diff_day$date)
dep_diff_day$date2 <- as.character(dep_diff_day$date)
dep_diff_day$groups[which(dep_diff_day$groups=="D_G")] <- "G_D"


dep_diff_day_sub <- dep_diff_day[,c("bat1","bat2","date1","date2","sameid","Deptimediff")]


#joint two dataframes
dep_diff_feb <- rbind(dep_diff_sub, dep_diff_day_sub)
dep_diff_feb$cave <- "dry_2022-1"

#plot departure time difference for individuals
ggplot(dep_diff_feb, aes(x=sameid, y=Deptimediff))+
  geom_boxplot()+
  geom_jitter()+
  stat_summary(fun = mean, color = "red") +
  stat_summary(
    fun.min = function(x) mean(x) - sd(x), 
    fun.max = function(x) mean(x) + sd(x), 
    geom = "errorbar",
    color = "red",
    width = .3
  )+
  ylab("departure time difference (min)")+
  theme_classic()

ggsave(file="~/ownCloud/PhDLife/P.hastatus/Thesis/Paper3/analysis/figures/depdiff_sameid_yesno.pdf", width=15, height=5)

# plot as a heat map
# ggplot(aes(x=bat1, y=bat2, fill=Deptimediff), data = dep_diff_feb)+
#   geom_tile()+
#   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
#   ggtitle("February")+
#   xlab("bats")+
#   ylab("bats")

```


## Plot time departure difference by individuals all days and by day including all individuals
```{r}
library(patchwork)
#plot by individuals
p1 <- ggplot(aes(x=bat, y=Deptimediff), data=dep_diff)+
  geom_boxplot()+
  geom_jitter()+
  ylab("departure time difference (mins)")+
  theme(legend.position="none")

#plot by all days
p2 <- ggplot(aes(x=as.factor(date), y=Deptimediff), data=dep_diff_day)+
  geom_boxplot()+
  geom_jitter()+
  ylab("departure time difference (mins)")+
  theme(legend.position="none")+
  xlab("date")

p1/p2 

ggsave(file="~/ownCloud/PhDLife/P.hastatus/Thesis/Paper3/analysis/figures/depdiff_ind_group_variation.pdf", width=15, height=5)
```


### Look at the similarity of the returns within and between individuals in 2022

```{r}
commu_feb_ret_id <- split(commu_feb_ret, f=commu_feb_ret$tag_local_identifier)

ret_diff <-  rbindlist(lapply(commu_feb_ret_id, FUN=function(t){
  combi <- t(combn(as.character(t$date), 2)) # all unique pairwise combinations of individuals
  bat <- unique(t$tag_local_identifier)# UTC time
  combi <- data.frame(date1=combi[,1], date2=combi[,2], bat=bat, stringsAsFactors=F) # set up a new data frame
  combi <- combi[combi$date1!=combi$date2,]# just in case that a single bat has two readings for the same timestamp
  
  combi$Deptimediff <- unlist(lapply(1:nrow(combi), function(i){ # calculate time difference between all pairs (in meters!!)
    pos.time1<- t[t$date==combi$date1[i], c('time')] # time for first bat
    pos.time2 <- t[t$date==combi$date2[i], 'time'] # time for second bat
    return(difftime(pos.time1$time, pos.time2$time, units = "mins"))})) # time in minutes
  return(combi)
  }))

#convert negative to possitive values
ret_diff$Deptimediff <- abs(ret_diff$Deptimediff)
ret_diff$bat1 <- ret_diff$bat
ret_diff$bat2 <- ret_diff$bat
ret_diff$sameid <- "yes"
ret_diff$date <- paste(ret_diff$date1, ret_diff$date2, sep="_")
#subset dataframe
ret_diff_sub <- ret_diff[,c("bat1","bat2","date1","date2","sameid","Deptimediff")]

#split by day
commu_feb_ret_day <- split(commu_feb_ret, f=commu_feb_ret$date)

ret_diff_day <-  rbindlist(lapply(commu_feb_ret_day[1:11], FUN=function(t){
  combi <- t(combn(t$tag_local_identifier, 2)) # all unique pairwise combinations of individuals
  date <- unique(t$date)# UTC time
  combi <- data.frame(bat1=combi[,1], bat2=combi[,2], date=date, stringsAsFactors=F) # set up a new data frame
  combi <- combi[combi$bat1!=combi$bat2,]# just in case that a single bat has two readings for the same timestamp
  
  combi$Deptimediff <- unlist(lapply(1:nrow(combi), function(i){ # calculate time difference between all pairs (in meters!!)
    pos.time1<- t[t$tag_local_identifier==combi$bat1[i], c('timestamp')] # location for first bat
    pos.time2 <- t[t$tag_local_identifier==combi$bat2[i], 'timestamp'] # location for second bat
    return(difftime(pos.time1$timestamp, pos.time2$timestamp, units="mins"))})) # geographic distance between bats (in meters)
  return(combi)
  }))

#convert negative to positive values
ret_diff_day$Deptimediff <- abs(ret_diff_day$Deptimediff)

#add groups
ret_diff_day <- ret_diff_day %>%
  mutate(group1=str_sub(bat1, 10, 10), group2=str_sub(bat2, 10, 10), groups=paste(group1,group2, sep="_"), bat=paste(bat1, bat2, sep="_"))

ret_diff_day$groups[which(ret_diff_day$groups=="D_G")] <- "G_D"

ret_diff_day$sameid <- "no"

ret_diff_day$date1 <- as.character(ret_diff_day$date)
ret_diff_day$date2 <- as.character(ret_diff_day$date)

ret_diff_day_sub <- ret_diff_day[,c("bat1","bat2","date1","date2","sameid","Deptimediff")]
#joint two dataframes
ret_diff_feb <- rbind(ret_diff_sub, ret_diff_day_sub)
ret_diff_feb$cave <- "dry_2022-1"

#plot return time difference for individuals
ggplot(ret_diff_feb, aes(x=sameid, y=Deptimediff))+
  geom_boxplot()+
  geom_jitter()+
  stat_summary(fun = mean, color = "red") +
  stat_summary(
    fun.min = function(x) mean(x) - sd(x), 
    fun.max = function(x) mean(x) + sd(x), 
    geom = "errorbar",
    color = "red",
    width = .3
  )+
  ylab("return time difference")+
  theme_classic()

ggsave(file="~/ownCloud/PhDLife/P.hastatus/Thesis/Paper3/analysis/figures/retdiff_sameid.pdf", width=15, height=5)

```

### Plot return times for february

```{r}
#plot by individuals
p3 <- ggplot(aes(x=bat, y=Deptimediff), data=ret_diff)+
  geom_boxplot()+
  geom_jitter()+
  ylab("return time difference (mins)")#+
  #theme(legend.position="none")

#plot by all days
p4 <- ggplot(aes(x=as.factor(date), y=Deptimediff), data=ret_diff_day)+
  geom_boxplot()+
  geom_jitter(width = 0.3)+
  ylab("return time difference (mins)")+
  theme(legend.position="none")


p3/p4
ggsave(file="~/ownCloud/PhDLife/P.hastatus/Thesis/Paper3/analysis/figures/retdiff_ind_group.pdf", width=15, height=5)
```

### Departures and returns for 2022 march data
```{r}
library(readxl)
dep_ret_march <- read_csv("~/ownCloud/PhDLife/P.hastatus/Thesis/Paper3/data/departures_returns_march_2.csv")

# animal 098 is not there find out
dep_ret_march$date <- date(dep_ret_march$departure_start)

#to extract tag id and include in the dataframe
dep_ret_march <- dep_ret_march %>%
  mutate(tag_local_identifier = str_sub(Tag, start = 1, end = 9))%>%
  filter(tag_local_identifier!="PH_TS_056")#remove one individual with only two nights of tracking

# use only complete information
commu_march_dep <- dep_ret_march %>%
  filter(`use in analysis`=="yes"& cave_group=="ajcave") 

commu_march_dep <- commu_march_dep[order(commu_march_dep$Tag),]
commu_march_dep <- as.data.frame(commu_march_dep)

commu_march_dep$departure_start <- as.POSIXct(commu_march_dep$departure_start, format = "%Y-%m-%d %H:%M:%S")
commu_march_dep$time <- format(commu_march_dep$departure_start, format = "%H:%M:%S")
commu_march_dep$time <- as.POSIXct(commu_march_dep$time, format = "%H:%M:%S", tz="UTC")

### remove individuals which are females
commu_march_dep <- commu_march_dep%>%
  filter(tag_local_identifier!="PH_TS_081" , tag_local_identifier!= "PH_TS_103", tag_local_identifier!="PH_TS_018")
```

### Calculate pairwise comparison in departures within and between ids

```{r}
# split data frame by id
commu_march_dep_id <- split(commu_march_dep, f=commu_march_dep$tag_local_identifier)

# calculate departure time difference by idday
dep_diff_march_id <-  rbindlist(lapply(commu_march_dep_id, FUN=function(t){
  combi <- t(combn(as.character(t$date), 2)) # all unique pairwise combinations of individuals
  bat <- unique(t$tag_local_identifier)# UTC time
  combi <- data.frame(date1=combi[,1], date2=combi[,2], bat=bat, stringsAsFactors=F) # set up a new data frame
  combi <- combi[combi$date1!=combi$date2,]# just in case that a single bat has two readings for the same timestamp
  
  # Initialize the Deptimediff column first
  combi$Deptimediff <- NA
  
  # Now calculate and assign the time differences
  for(i in 1:nrow(combi)) {
    pos.time1 <- t[t$date==combi$date1[i], c('time')]
    pos.time2 <- t[t$date==combi$date2[i], 'time']
    combi$Deptimediff[i] <- difftime(pos.time1, pos.time2, units="mins")
  }
  return(combi)
}))

# convert negative to positive values
dep_diff_march_id$Deptimediff <- abs(dep_diff_march_id$Deptimediff)
dep_diff_march_id$bat1 <- dep_diff_march_id$bat
dep_diff_march_id$bat2 <- dep_diff_march_id$bat
dep_diff_march_id$cave <- "dry_2022-2"
dep_diff_march_id$sameid <- "yes"

# split by day
commu_march_dep_day <- split(commu_march_dep, f=commu_march_dep$date)

dep_diff_march_day <- rbindlist(lapply(commu_march_dep_day[1:11], FUN=function(t){
  combi <- t(combn(unique(t$tag_local_identifier), 2)) # use unique to avoid duplicates
  date <- unique(t$date)
  combi <- data.frame(bat1=combi[,1], bat2=combi[,2], date=date, stringsAsFactors=F)
  combi <- combi[combi$bat1!=combi$bat2,]
  
  # Initialize Deptimediff column
  combi$Deptimediff <- NA
  
  # Calculate time differences using a for loop
  for(i in 1:nrow(combi)) {
    pos.time1 <- t$departure_start[t$tag_local_identifier == combi$bat1[i]][1]
    pos.time2 <- t$departure_start[t$tag_local_identifier == combi$bat2[i]][1]
    combi$Deptimediff[i] <- difftime(pos.time1, pos.time2, units="mins")
  }
  return(combi)
}))

# convert negative to positive values
dep_diff_march_day$Deptimediff <- abs(dep_diff_march_day$Deptimediff)

# add cave identity
dep_diff_march_day$cave1 <- commu_march_dep$cave_group[match(dep_diff_march_day$bat1, commu_march_dep$tag_local_identifier)]
dep_diff_march_day$cave2 <- commu_march_dep$cave_group[match(dep_diff_march_day$bat2, commu_march_dep$tag_local_identifier)]
dep_diff_march_day$cave <- "dry_2022-2"
dep_diff_march_day$samecave <- ifelse(dep_diff_march_day$cave1 == dep_diff_march_day$cave2, "yes", "no")
dep_diff_march_day$sameid <- "no"
dep_diff_march_day$date1 <- as.character(dep_diff_march_day$date)
dep_diff_march_day$date2 <- as.character(dep_diff_march_day$date)
#dep_diff_march_day$bat <-paste(dep_diff_march_day$bat1,dep_diff_march_day$bat2, sep="_")

# filter comparison between individuals of the same cave
dep_diff_march_day <- dep_diff_march_day[dep_diff_march_day$samecave=="yes",]

# merge two dataframes
dep_diff_march <- rbind(dep_diff_march_id[,c("bat1","bat2","date1","date2","Deptimediff", "cave","sameid")], dep_diff_march_day[,c("bat1","bat2","date1","date2","Deptimediff", "cave","sameid")])

# plot departure time difference for individuals
ggplot(dep_diff_march, aes(x=sameid, y=Deptimediff))+
  geom_boxplot()+
  geom_jitter()+
  stat_summary(fun = mean, color = "red") +
  stat_summary(
    fun.min = function(x) mean(x) - sd(x), 
    fun.max = function(x) mean(x) + sd(x), 
    geom = "errorbar",
    color = "red",
    width = .3
  )+
  ylab("departure time difference")+
  theme_classic()

ggsave(file="~/ownCloud/PhDLife/P.hastatus/Thesis/Paper3/analysis/figures/depdiff_march_sameid.pdf", width=15, height=5)

```

### Plot departures for 2022 march

```{r}
#plot by individuals
p5 <- ggplot(aes(x=bat, y=Deptimediff, color=as.factor(cave)), data=dep_diff_march_id)+
  geom_boxplot()+
  geom_jitter()+
  ylab("departure time difference (mins)")+
  theme(legend.position="none")

#plot by all days
p6 <- ggplot(aes(x=as.factor(date), y=Deptimediff), data=dep_diff_march_day)+
  geom_boxplot()+
  geom_jitter()+
  ylab("departure time difference (mins)")+
  theme(legend.position="none")

p5/p6

ggsave(file="~/ownCloud/PhDLife/P.hastatus/Thesis/Paper3/analysis/figures/depdiff_ind_days_march.pdf", width=15, height=5)
```

### Calculate return times for bats in 2022 march 

```{r}
commu_march_dep$return_stop<- as.POSIXct(commu_march_dep$return_stop, format = "%Y-%m-%d %H:%M:%S", tz="UTC")
commu_march_dep$time_ret <- format(as.POSIXct(commu_march_dep$return_stop), format = "%H:%M:%S")
commu_march_dep$time_ret <- as.POSIXct(commu_march_dep$time_ret, format = "%H:%M:%S", tz="UTC")
commu_march_dep <- commu_march_dep %>%
  filter(Tag!="PH_TS_120_2022-03-11")# return time is wrong

# split data frame by id
commu_march_ret_id <- split(commu_march_dep, f=commu_march_dep$tag_local_identifier)

# calculate departure time difference by idday
ret_diff_march_id <-  rbindlist(lapply(commu_march_ret_id, FUN=function(t){
   combi <- t(combn(as.character(date(t$return_start)), 2)) # all unique pairwise combinations of individuals
   bat <- unique(t$tag_local_identifier)# UTC time
   combi <- data.frame(date1=combi[,1], date2=combi[,2], bat=bat, stringsAsFactors=F) # set up a new data frame
   combi <- combi[combi$date1!=combi$date2,]# just in case that a single bat has two readings for the same timestamp

 
   combi$Deptimediff <- unlist(lapply(1:nrow(combi), function(i){ # calculate time difference between all pairs (in meters!!)
     pos.time1<- t[t$date==combi$date1[i], c('time_ret')] # 
     pos.time2 <- t[t$date==combi$date2[i], 'time_ret'] # 
     return(difftime(pos.time1, pos.time2, units="mins"))})) # time in min
   return(combi)
   }))

# convert negative to positive values
ret_diff_march_id$Deptimediff <- abs(ret_diff_march_id$Deptimediff)
ret_diff_march_id$bat1 <- ret_diff_march_id$bat
ret_diff_march_id$bat2 <- ret_diff_march_id$bat
ret_diff_march_id$cave <- "dry_2022-2"
ret_diff_march_id$sameid <- "yes"

#  split data frame by date
commu_march_ret_day <- split(commu_march_dep, f=commu_march_dep$date)

ret_diff_march_day <-  rbindlist(lapply(commu_march_ret_day[1:12], FUN=function(t){
  combi <- t(combn(t$tag_local_identifier, 2)) # all unique pairwise combinations of individuals
  date <- unique(t$date)# UTC time
  combi <- data.frame(bat1=combi[,1], bat2=combi[,2], date=date, stringsAsFactors=F) # set up a new data frame
  combi <- combi[combi$bat1!=combi$bat2,]# just in case that a single bat has two readings for the same timestamp
  
  combi$Deptimediff <- unlist(lapply(1:nrow(combi), function(i){ # calculate time difference between all pairs (in meters!!)
    pos.time1<- t[t$tag_local_identifier==combi$bat1[i], c('return_stop')] # location for first bat
    pos.time2 <- t[t$tag_local_identifier==combi$bat2[i], 'return_stop'] # location for second bat
    return(difftime(pos.time1, pos.time2, units="mins"))})) # geographic distance between bats (in meters)
  return(combi)
  }))

# convert negative to positive values
ret_diff_march_day$Deptimediff <- abs(ret_diff_march_day$Deptimediff)

# add cave identity
ret_diff_march_day$cave1 <- commu_march_dep$cave_group[match(ret_diff_march_day$bat1, commu_march_dep$tag_local_identifier)]
ret_diff_march_day$cave2 <- commu_march_dep$cave_group[match(ret_diff_march_day$bat2, commu_march_dep$tag_local_identifier)]
ret_diff_march_day$cave <- "dry_2022-2" 
ret_diff_march_day$samecave <- ifelse(ret_diff_march_day$cave1 == ret_diff_march_day$cave2, "yes", "no")
ret_diff_march_day$sameid <- "no"
ret_diff_march_day$date1 <- as.character(ret_diff_march_day$date)
ret_diff_march_day$date2 <- as.character(ret_diff_march_day$date)
#ret_diff_march_day$bat <-paste(ret_diff_march_day$bat1,ret_diff_march_day$bat2, sep="_")

# filter comparison between individuals of the same cave
ret_diff_march_day <- ret_diff_march_day[ret_diff_march_day$samecave=="yes",]

# merge two dataframes
ret_diff_march <- rbind(ret_diff_march_id[,c("bat1","bat2","date1","date2","Deptimediff", "cave","sameid")], ret_diff_march_day[,c("bat1","bat2","date1","date2","Deptimediff", "cave","sameid")])

# plot departure time difference for individuals
ggplot(ret_diff_march, aes(x=sameid, y=Deptimediff))+
  geom_boxplot()+
  geom_jitter()+
  stat_summary(fun = mean, color = "red") +
  stat_summary(
    fun.min = function(x) mean(x) - sd(x), 
    fun.max = function(x) mean(x) + sd(x), 
    geom = "errorbar",
    color = "red",
    width = .3
  )+
  ylab("return time difference")+
  theme_classic()

ggsave(file="~/ownCloud/PhDLife/P.hastatus/Thesis/Paper3/analysis/figures/retdiff_march_sameid.pdf", width=15, height=5)
```

## Extract departure times for 2023 data

```{r}
bats_2023 <- hast_df%>%
  filter(date>"2023-01-01")

# split data frame by ID_day
bats_2023_split <- split(bats_2023, bats_2023$ID)

bats_2023_split <- bats_2023_split[names(bats_2023_split)%in% c("PHYL11_2023-08-15", "PHYL11_2023-08-16", "PHYL11_2023-08-17", "PHYL11_2023-08-18", "PHYL16_2023-08-14", "PHYL16_2023-08-15",  "PHYL21_2023-08-18", "PHYL24_2023-08-15", "PHYL21_2023-08-17", "PHYL25_2023-08-14", "PHYL25_2023-08-15", "PHYL25_2023-08-16",  "PHYL25_2023-08-18", "PHYL27_2023-08-15",   "PHYL35_2023-08-14", "PHYL39_2023-08-14",  "PHYL7_2023-08-16", "PHYL7_2023-08-16","PHYL7_2023-08-17", "PHYL7_2023-08-18")==TRUE]

bats_2023 <- do.call(rbind, bats_2023_split)

# filter only commuting with more than 5 points in a row
bats_commu2023 <- bats_2023  %>% 
  filter(behav=="commuting" & n>=10)

ggplot(aes(x=location_long, y=location_lat, col=ID), data=bats_commu2023) + geom_point()

# take the first row of each id date in the commuting tracks
commu_2023_dep <- bats_commu2023 %>%
  group_by(ID) %>%
  slice(which.min(1:n()))


# add time to the data frame
commu_2023_dep$time <- format(commu_2023_dep$timestamp, format = "%H:%M:%S")
commu_2023_dep$time <- as.POSIXct(commu_2023_dep$time, format = "%H:%M:%S", tz="UTC")
commu_2023_dep$time_num <-  as.numeric(as_hms(commu_2023_dep$time))

```


### Calculate pairwise departure times for 2023
```{r}
# split data frame by id
commu_2023_dep <- commu_2023_dep[commu_2023_dep$tag_local_identifier!="PHYL1",]
commu_2023_dep_id <- split(commu_2023_dep, f=commu_2023_dep$tag_local_identifier)

# calculate departure time difference by idday
dep_diffid_2023<-  rbindlist(lapply(commu_2023_dep_id, FUN=function(t){
  combi <- t(combn(as.character(t$date), 2)) # all unique pairwise combinations of individuals
  bat <- unique(t$tag_local_identifier)# UTC time
  combi <- data.frame(date1=combi[,1], date2=combi[,2], bat=bat, stringsAsFactors=F) # set up a new data frame
  combi <- combi[combi$date1!=combi$date2,]# just in case that a single bat has two readings for the same timestamp
  
  combi$Deptimediff <- unlist(lapply(1:nrow(combi), function(i){ # calculate time difference between all pairs (in meters!!)
    pos.time1<- t[t$date==combi$date1[i], c('time')] # time for first bat
    pos.time2 <- t[t$date==combi$date2[i], 'time'] # time for second bat
    return(difftime(pos.time1$time, pos.time2$time, units="mins"))})) # geographic distance between bats (in meters)
  return(combi)
  }))

# convert negative to positive values
dep_diffid_2023$Deptimediff <- abs(dep_diffid_2023$Deptimediff)
dep_diffid_2023$bat1 <- dep_diffid_2023$bat
dep_diffid_2023$bat2 <- dep_diffid_2023$bat
dep_diffid_2023$sameid <- "yes"
dep_diffid_2023$date <- paste(dep_diffid_2023$date1, dep_diffid_2023$date2, sep="_")
# subset dataframe
dep_diffid_2023_sub <- dep_diffid_2023[,c("bat1","bat2","date1","date2","sameid","Deptimediff")]
dep_diffid_2023_sub$cave <- "2023_wet"

# split by day
commu_2023_dep_day <- split(commu_2023_dep, f=commu_2023_dep$date)

dep_diff_day_2023 <-  rbindlist(lapply(commu_2023_dep_day, FUN=function(t){
  combi <- t(combn(t$tag_local_identifier, 2)) # all unique pairwise combinations of individuals
  date <- unique(t$date)# UTC time
  combi <- data.frame(bat1=combi[,1], bat2=combi[,2], date=date, stringsAsFactors=F) # set up a new data frame
  combi <- combi[combi$bat1!=combi$bat2,]# just in case that a single bat has two readings for the same timestamp
  
  combi$Deptimediff <- unlist(lapply(1:nrow(combi), function(i){ # calculate time difference between all pairs (in meters!!)
    pos.time1<- t[t$tag_local_identifier==combi$bat1[i], 'timestamp'] # time for first bat
    pos.time2 <- t[t$tag_local_identifier==combi$bat2[i], 'timestamp'] # time for second bat
    return(difftime(pos.time1$timestamp, pos.time2$timestamp, units="mins"))})) # geographic distance between bats (in meters)
  return(combi)
  }))

# convert negative to positive values
dep_diff_day_2023$Deptimediff <- abs(dep_diff_day_2023$Deptimediff)

dep_diff_day_2023 <- dep_diff_day_2023 %>%
  mutate(group1=str_sub(bat1, 10, 10), group2=str_sub(bat2, 10, 10), groups=paste(group1,group2, sep="_"), bat=paste(bat1, bat2, sep="_"))

dep_diff_day_2023$sameid <- "no"
dep_diff_day_2023$date1 <- as.character(dep_diff_day_2023$date)
dep_diff_day_2023$date2 <- as.character(dep_diff_day_2023$date)
dep_diff_day_sub_2023 <- dep_diff_day_2023[,c("bat1","bat2","date1","date2","sameid","Deptimediff")]

dep_diff_day_sub_2023$cave <- "2023_wet"
dep_diff_day_sub_2023$samecave <-"yes"

# joint two dataframes
dep_diff_2023 <- rbind(dep_diffid_2023_sub[,c("bat1","bat2","date1","date2","sameid","Deptimediff","cave")], dep_diff_day_sub_2023[,c("bat1","bat2","date1","date2","sameid","Deptimediff","cave")])

# plot departure time difference for individuals
ggplot(dep_diff_2023, aes(x=sameid, y=Deptimediff))+
  geom_boxplot()+
  geom_jitter()+
  stat_summary(fun = mean, color = "red") +
  stat_summary(
    fun.min = function(x) mean(x) - sd(x), 
    fun.max = function(x) mean(x) + sd(x), 
    geom = "errorbar",
    color = "red",
    width = .3
  )+
  ylab("departure time difference (min)")+
  theme_classic()
```
### Extract return times for 2023

```{r}
# extract return foraging locations
commu_2023_ret <- bats_commu2023 %>%
  group_by(ID) %>%
  slice(which.max(1:n()))

#add time to the data frame
commu_2023_ret$time <- format(as.POSIXct(commu_2023_ret$timestamp), format = "%H:%M:%S")
commu_2023_ret$time <- as.POSIXct(commu_2023_ret$time, format = "%H:%M:%S", tz="UTC")
commu_2023_ret$time_num <-  as.numeric(as_hms(commu_2023_ret$time))
```

### Calculate return times for 2023

```{r}
# split data frame by id
commu_2023_ret_id <- split(commu_2023_ret, f=commu_2023_ret$tag_local_identifier)

# calculate departure time difference by idday
ret_diffid_2023<-  rbindlist(lapply(commu_2023_ret_id, FUN=function(t){
  combi <- t(combn(as.character(t$date), 2)) # all unique pairwise combinations of individuals
  bat <- unique(t$tag_local_identifier)# UTC time
  combi <- data.frame(date1=combi[,1], date2=combi[,2], bat=bat, stringsAsFactors=F) # set up a new data frame
  combi <- combi[combi$date1!=combi$date2,]# just in case that a single bat has two readings for the same timestamp
  
  combi$Deptimediff <- unlist(lapply(1:nrow(combi), function(i){ # calculate time difference between all pairs (in meters!!)
    pos.time1<- t[t$date==combi$date1[i], c('time')] # time for first bat
    pos.time2 <- t[t$date==combi$date2[i], 'time'] # time for second bat
    return(difftime(pos.time1$time, pos.time2$time, units="mins"))})) # geographic distance between bats (in meters)
  return(combi)
  }))

# convert negative to positive values
ret_diffid_2023$Deptimediff <- abs(ret_diffid_2023$Deptimediff)
ret_diffid_2023$bat1 <- ret_diffid_2023$bat
ret_diffid_2023$bat2 <- ret_diffid_2023$bat
ret_diffid_2023$sameid <- "yes"
ret_diffid_2023$date <- paste(ret_diffid_2023$date1, ret_diffid_2023$date2, sep="_")
# subset dataframe
ret_diffid_20233_sub <- ret_diffid_2023[,c("bat1","bat2","date1","date2","sameid","Deptimediff")]
ret_diffid_20233_sub$cave <- "2023_wet"

# split by day
commu_2023_ret_day <- split(commu_2023_ret, f=commu_2023_ret$date)

ret_diff_day_2023 <-  rbindlist(lapply(commu_2023_ret_day[c(-1)], FUN=function(t){
  combi <- t(combn(t$tag_local_identifier, 2)) # all unique pairwise combinations of individuals
  date <- unique(t$date)# UTC time
  combi <- data.frame(bat1=combi[,1], bat2=combi[,2], date=date, stringsAsFactors=F) # set up a new data frame
  combi <- combi[combi$bat1!=combi$bat2,]# just in case that a single bat has two readings for the same timestamp
  
  combi$Deptimediff <- unlist(lapply(1:nrow(combi), function(i){ # calculate time difference between all pairs (in meters!!)
    pos.time1<- t[t$tag_local_identifier==combi$bat1[i], 'timestamp'] # time for first bat
    pos.time2 <- t[t$tag_local_identifier==combi$bat2[i], 'timestamp'] # time for second bat
    return(difftime(pos.time1$timestamp, pos.time2$timestamp, units="mins"))})) # geographic distance between bats (in meters)
  return(combi)
  }))

# convert negative to positive values
ret_diff_day_2023$Deptimediff <- abs(ret_diff_day_2023$Deptimediff)

ret_diff_day_2023 <- ret_diff_day_2023 %>%
  mutate(group1=str_sub(bat1, 10, 10), group2=str_sub(bat2, 10, 10), groups=paste(group1,group2, sep="_"), bat=paste(bat1, bat2, sep="_"))

ret_diff_day_2023$sameid <- "no"
ret_diff_day_2023$date1 <- ret_diff_day_2023$date
ret_diff_day_2023$date2 <- ret_diff_day_2023$date

ret_diff_day_sub_2023 <- ret_diff_day_2023[,c("bat1","bat2","date1","date2","sameid","Deptimediff")]
ret_diff_day_sub_2023$date1 <- as.character(ret_diff_day_sub_2023$date1)
ret_diff_day_sub_2023$date2 <- as.character(ret_diff_day_sub_2023$date2)
# ret_diff_day_sub_2023$cave1 <- commu_2023_ret$year_cave[match(ret_diff_day_sub_2023$bat1, commu_2023_ret$tag_local_identifier)]
# ret_diff_day_sub_2023$cave2 <- commu_2023_ret$year_cave[match(ret_diff_day_sub_2023$bat2, commu_2023_ret$tag_local_identifier)]

#ret_diff_day_sub_2023$samecave <-"yes"
ret_diff_day_sub_2023$cave <- "2023_wet"

# joint two dataframes
ret_diff_2023 <- rbind(ret_diffid_20233_sub[,c("bat1","bat2","date1","date2","sameid","Deptimediff","cave")], ret_diff_day_sub_2023[,c("bat1","bat2","date1","date2","sameid","Deptimediff","cave")])

# plot departure time difference for individuals
ggplot(ret_diff_2023, aes(x=sameid, y=Deptimediff))+
  geom_boxplot()+
  geom_jitter()+
  stat_summary(fun = mean, color = "red") +
  stat_summary(
    fun.min = function(x) mean(x) - sd(x), 
    fun.max = function(x) mean(x) + sd(x), 
    geom = "errorbar",
    color = "red",
    width = .3
  )+
  ylab("return time difference (min)")+
  theme_classic()

```
### Combine departure and return dataframes
```{r}
# combine departure dataframes
depdiff_all <- rbind(dep_diff_feb, dep_diff_march,dep_diff_2023)
depdiff_all$season <- factor(depdiff_all$cave, levels = c("dry_2022-1","dry_2022-2", "2023_wet"), labels = c("dry 2022-1","dry 2022-2", "2023 wet"))
depdiff_all$sameid <- factor(depdiff_all$sameid, levels=c("yes","no"))


depdiff_all <- depdiff_all %>%
  mutate(group1=str_sub(bat1, 10, 10), group2=str_sub(bat2, 10, 10), groups=paste(group1, group2, sep="_"))

depdiff_all$groups[which(depdiff_all$groups=="D_G")] <- "G_D"
depdiff_all$groups[which(depdiff_all$groups=="_")] <- "NA"

write.csv(depdiff_all,file="/Users/ccalderon/ownCloud/PhDLife/P.hastatus/Thesis/Paper3/data/alldepartures.csv")

# combine return dataframes
ret_diff_all <- rbind(ret_diff_feb, ret_diff_march,ret_diff_2023)
ret_diff_all$season <- factor(ret_diff_all$cave, levels = c("dry_2022-1","dry_2022-2", "2023_wet"), labels = c("dry 2022-1","dry 2022-2", "2023 wet"))
ret_diff_all$sameid <- factor(ret_diff_all$sameid, levels=c("yes","no"))

write.csv(ret_diff_all,file="/Users/ccalderon/ownCloud/PhDLife/P.hastatus/Thesis/Paper3/data/allreturns.csv")
```
### Plot departure and return times pairwise difference for all tracking periods
```{r}
# only color strips in x-direction
library(ggh4x)
strip <- strip_themed(background_x = elem_list_rect(fill = c("#756BB1", "#21918c","#F0E442"), alpha=c(0.5)))
# necessary to put RH% into the facet labels
period_names <- as_labeller(
     c(`dry 2022-1` = "Dry 2022-1", `dry 2022-2` = "Dry 2022-2",`2023 wet` = "Wet 2023"))

# plot departure time difference
dep_plot <- ggplot(data=depdiff_all, aes(x=sameid, color=sameid, group = sameid))+
  scale_color_manual(values = c("black", "grey"))+
  geom_jitter(aes(y = Deptimediff,  alpha=sameid), position = position_jitterdodge(jitter.width = 0.4, jitter.height = 0.05))+
  scale_x_discrete(labels = c("within", "between"))+
  scale_alpha_manual(values = c(0.5,0.5))+
  stat_summary(aes(y=Deptimediff, group = sameid),fun = mean, color = "red",
    position = position_dodge(.8)) +
  stat_summary(aes(y=Deptimediff, group=sameid),
    fun.min = function(x) mean(x) - sd(x), 
    fun.max = function(x) mean(x) + sd(x), 
    geom = "errorbar",
    color = "red",
    width = .3,
    position = position_dodge(.8)
  )+
  facet_wrap2(.~season, strip=strip, labeller = period_names, scales = "free")+
  guides(color="none", alpha="none")+
  ylab("Departure time \n difference (min)")+
  xlab("Individuals")+
  theme_classic()+
  theme(legend.position = "none", axis.title = element_text(size=20), axis.title.x = element_text(size = 20), axis.title.y=element_text(size=20), axis.text.y = element_text(size=14), axis.text.x = element_text(size=14))

ggsave(file="~/ownCloud/PhDLife/P.hastatus/Thesis/Paper3/analysis/figures/departure_all.pdf")

# plot return time difference
ret_plot <- ggplot(data=ret_diff_all, aes(x=sameid, color=sameid, group = sameid))+
  scale_color_manual(values = c("black", "grey"))+
  geom_jitter(aes(y = Deptimediff,  alpha=sameid), position = position_jitterdodge(jitter.width = 0.2, jitter.height = 0.05))+
  scale_x_discrete(labels = c("within", "between"))+
  scale_alpha_manual(values = c(0.5,0.5))+
  stat_summary(aes(y=Deptimediff, group = sameid),fun = mean, color = "red",
    position = position_dodge(.8)) +
  stat_summary(aes(y=Deptimediff, group=sameid),
    fun.min = function(x) mean(x) - sd(x), 
    fun.max = function(x) mean(x) + sd(x), 
    geom = "errorbar",
    color = "red",
    width = .3,
    position = position_dodge(.8)
  )+
  facet_wrap2(.~season, strip=strip, labeller = period_names, scales = "free")+
  guides(color="none", alpha="none")+
  ylab("Return time difference (min)")+
  xlab("Individuals")+
  theme_classic()+
  theme(legend.position = "none", axis.title = element_text(size=20), axis.title.x = element_text(size = 20), axis.title.y=element_text(size=20), axis.text.y = element_text(size=14), axis.text.x = element_text(size=14))

ret_plot
ggsave(file="~/ownCloud/PhDLife/P.hastatus/Thesis/Paper3/analysis/figures/return_all.pdf", width = 7, height = 5)
```

### Test individual time departure difference within same and different individuals

```{r}
library(MuMIn)
#make zero values not zero
# dep_diff_feb$Deptimediff[dep_diff_feb$Deptimediff==0] <- 0.01
# set.seed(1)
# m_dep <- glmer(Deptimediff~sameid + (1|bat1)+ (1|bat2), family = Gamma("log"), data=dep_diff_feb)
# 
# # 
# summary(m_dep)
# par(mar=c(2, 2, 2, 2));qqnorm(residuals(m_dep),main=NULL)

hist(depdiff_all$Deptimediff)
##
depdiff_all$Deptimediff[depdiff_all$Deptimediff==0] <- 0.01
set.seed(1)

#join bat1 and bat2 together
depdiff_all$bats <- paste(depdiff_all$bat1, depdiff_all$bat2, sep="_")
depdiff_all$date <- paste(depdiff_all$date1, depdiff_all$date2, sep="_")

m_dep_all <- lmer(sqrt(Deptimediff)~sameid*season + (1|bats), data=depdiff_all)#(0 + sameid|bats)

m_dep_all
summary(m_dep_all)
car::Anova(m_dep_all)
r2 <- r.squaredGLMM(m_dep_all)
print(r2)


# Marginal means for the interaction of sameid and season
emm_interaction <- emmeans(m_dep_all, ~ sameid * season)

# Pairwise comparisons for the interaction
pairwise_interaction <- pairs(emm_interaction, adjust = "tukey")
pairwise_interaction

par(mar=c(2, 2, 2, 2));qqnorm(residuals(m_dep_all),main=NULL)

# check model
plot(m_dep_all)


simulationOutput <- simulateResiduals(fittedModel = m_dep_all, plot = F)
plot(simulationOutput)

mean_dep <- depdiff_all %>%
  group_by(sameid)%>%
  dplyr::summarise(meandep=mean(Deptimediff), sddep=sd(Deptimediff))

### using brms
# Load the package
#library(brms)

###Install required packages

# install.packages(c("remotes","devtools","miniCRAN","pacman"), dependencies = TRUE, type="source")
# 
# 
# list_of_required_packages <- c("brms")
# packages_to_install=as.character(miniCRAN::pkgDep(list_of_required_packages, suggests = TRUE, enhances = TRUE))
# install.packages(packages_to_install, type="source")
# 
# install.packages("cmdstanr", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))

# model_gamma_brms <- brm(
#   formula = Deptimediff ~ sameid + season + (1 | bats) + (1 | date1) +(1|date2), 
#   data = depdiff_all, 
#   family = Gamma(link = "log"),  # Specify Gamma family with log link
#   chains = 4,     # Number of MCMC chains
#   cores = 4,      # Use multiple cores to speed up computation
#   iter = 2000     # Number of iterations per chain (adjust if needed)
# )
# 
# # Summary of the model
# summary(model_gamma_brms)
```

### Test individual time return difference within same and different individuals

```{r}
hist(ret_diff_feb$Deptimediff)

set.seed(1)

#make zero values not zero
ret_diff_all$Deptimediff[ret_diff_all$Deptimediff==0] <- 0.01
hist(sqrt(ret_diff_all$Deptimediff))

#join bat1 and bat2 together
ret_diff_all$bats <- paste(ret_diff_all$bat1, ret_diff_all$bat2, sep="_")
ret_diff_all$date <- paste(ret_diff_all$date1, ret_diff_all$date2, sep="_")

m_ret_all <- lmer(sqrt(Deptimediff) ~ sameid*season + (1|bats),
                 data = ret_diff_all)
m_ret_all
summary(m_ret_all)
car::Anova(m_ret_all)

r2_r <- r.squaredGLMM(m_ret_all)
print(r2_r)


# Marginal means for the interaction of sameid and season
emm_inter <- emmeans(m_ret_all, ~ sameid * season)

# Pairwise comparisons for the interaction
pairwise_inter <- pairs(emm_inter, adjust = "tukey")

par(mar=c(2, 2, 2, 2));qqnorm(residuals(m_ret_all),main=NULL)

# check model
plot(m_ret_all)

simulationOutput <- simulateResiduals(fittedModel = m_ret_all, plot = F)
plot(simulationOutput)

mean_ret <- ret_diff_all %>%
  group_by(sameid)%>%
  dplyr::summarise(meanret=mean(Deptimediff), sdret=sd(Deptimediff))

```

### Calculating departures after sunset for each individual in february
```{r}
commu_feb_dep$minTimeLocal <- with_tz(commu_feb_dep$timestamp, tz="America/Panama")

# get sunrise/sunset times
coords <- cbind(-82.271541, 9.396448)
lagruta <- SpatialPoints(coords, proj4string = CRS("+proj=longlat +datum=WGS84"))
lagrutaUTM <- spTransform(lagruta, CRS("+proj=utm +zone=17 +datum=WGS84"))
library(maptools)
lagrutaLL <- spTransform(lagrutaUTM, CRS("+proj=longlat +datum=WGS84"))
sunset <- sunriset(coordinates(lagrutaLL), commu_feb_dep$minTimeLocal, direction="sunset", POSIXct.out=TRUE)[2]

# difference to sunset
commu_feb_dep$sunset <- sunset$time
commu_feb_dep$timeSinceSunset <- commu_feb_dep$minTimeLocal - commu_feb_dep$sunset
commu_feb_dep$timeSinceSunset[commu_feb_dep$timeSinceSunset<0] <- commu_feb_dep$timeSinceSunset[commu_feb_dep$timeSinceSunset<0]+1440

# total mean
mean(commu_feb_dep$timeSinceSunset) 
sd(commu_feb_dep$timeSinceSunset) 

# plot time after sunset by id
commu_feb_dep$date <- as.Date(commu_feb_dep$date, format="%d.%m.%Y")

write.csv(commu_feb_dep, file="/Users/ccalderon/ownCloud/PhDLife/P.hastatus/Thesis/Paper3/data/departures_feb.csv")

sunset_dep_feb<- ggplot(commu_feb_dep, aes(x=date, y=as.numeric(timeSinceSunset)))+
  geom_point()+
  #geom_smooth(method = "lm")+
   ylab("departure time after sunset (min)")+
  theme_classic()
  
ggsave(file="~/ownCloud/PhDLife/P.hastatus/Thesis/Paper3/analysis/figures/deptime_sunset.pdf", width=15, height=5)

# plot time after sunset by id/date
# ggplot(commu_feb_dep, aes(x=as.character(date), y=timeSinceSunset, colour= tag_local_identifier))+
#   geom_path()+
#   geom_point()
# ggsave(file="~/ownCloud/PhDLife/P.hastatus/Thesis/Paper3/analysis/figures/deptime_sunset_id.pdf", width=15, height=5)
```

### Calculating departures after sunset for each individual in march
```{r}
commu_march_dep$minTimeLocal <- with_tz(commu_march_dep$departure_start, tz="America/Panama")

# get sunrise/sunset times
coords <- cbind(-82.271541, 9.396448)
lagruta <- SpatialPoints(coords, proj4string = CRS("+proj=longlat +datum=WGS84"))
lagrutaUTM <- spTransform(lagruta, CRS("+proj=utm +zone=17 +datum=WGS84"))
library(maptools)
lagrutaLL <- spTransform(lagrutaUTM, CRS("+proj=longlat +datum=WGS84"))
sunset <- sunriset(coordinates(lagrutaLL), commu_march_dep$minTimeLocal, direction="sunset", POSIXct.out=TRUE)[2]

# difference to sunset
commu_march_dep$sunset <- sunset$time
commu_march_dep$timeSinceSunset <- commu_march_dep$minTimeLocal - commu_march_dep$sunset
commu_march_dep$timeSinceSunset[commu_march_dep$timeSinceSunset<0] <- commu_march_dep$timeSinceSunset[commu_march_dep$timeSinceSunset<0]+1440

# total mean
mean(commu_march_dep$timeSinceSunset) 
sd(commu_march_dep$timeSinceSunset) 

# plot time after sunset by id
commu_march_dep$date <- as.Date(commu_march_dep$date, format="%d.%m.%Y")

write.csv(commu_march_dep, file="/Users/ccalderon/ownCloud/PhDLife/P.hastatus/Thesis/Paper3/data/departures_march.csv")

sunset_dep_march <- ggplot(commu_march_dep, aes(x=date, y=as.numeric(timeSinceSunset)))+
  geom_point()+
  ylab("departure time after sunset (min)")+
  theme_classic()#+
  #geom_smooth(method = "lm")
  
ggsave(file="~/ownCloud/PhDLife/P.hastatus/Thesis/Paper3/analysis/figures/deptime_sunset.pdf", width=15, height=5)

# plot time after sunset by id/date
ggplot(commu_march_dep, aes(x=date, y=timeSinceSunset, color = tag_local_identifier))+
  geom_path()+
  geom_point()
ggsave(file="~/ownCloud/PhDLife/P.hastatus/Thesis/Paper3/analysis/figures/deptime_sunset_id.pdf", width=15, height=5)
```

### Calculating departures after sunset for each individual in 2023
```{r}
commu_2023_dep$minTimeLocal <- with_tz(commu_2023_dep$timestamp, tz="America/Panama")

# get sunrise/sunset times
coords <- cbind(-82.271541, 9.396448)
lagruta <- SpatialPoints(coords, proj4string = CRS("+proj=longlat +datum=WGS84"))
lagrutaUTM <- spTransform(lagruta, CRS("+proj=utm +zone=17 +datum=WGS84"))
library(maptools)
lagrutaLL <- spTransform(lagrutaUTM, CRS("+proj=longlat +datum=WGS84"))
sunset_2023 <- sunriset(coordinates(lagrutaLL), commu_2023_dep$minTimeLocal, direction="sunset", POSIXct.out=TRUE)[2]

# difference to sunset
commu_2023_dep$sunset <- sunset_2023$time
commu_2023_dep$timeSinceSunset <- as.numeric(commu_2023_dep$minTimeLocal - commu_2023_dep$sunset)*60
commu_2023_dep$timeSinceSunset[commu_2023_dep$timeSinceSunset<0] <- commu_2023_dep$timeSinceSunset[commu_2023_dep$timeSinceSunset<0]+1440
commu_2023_dep$timeSinceSunset <- as.numeric(commu_2023_dep$timeSinceSunset)
# total mean
mean(commu_2023_dep$timeSinceSunset) 
sd(commu_2023_dep$timeSinceSunset) 

# plot time after sunset by id
commu_2023_dep$date <- as.Date(commu_2023_dep$date, format="%d.%m.%Y")

sunset_dep_2023 <- ggplot(commu_2023_dep, aes(x=date, y=as.numeric(timeSinceSunset)))+
  geom_point()+
  ylab("departure time after sunset (min)")+
  theme_classic()
  
ggsave(file="~/ownCloud/PhDLife/P.hastatus/Thesis/Paper3/analysis/figures/deptime_sunset.pdf", width=15, height=5)

# plot time after sunset by id/date
ggplot(commu_2023_dep, aes(x=date, y=timeSinceSunset, color = tag_local_identifier))+
  geom_path()+
  geom_point()
ggsave(file="~/ownCloud/PhDLife/P.hastatus/Thesis/Paper3/analysis/figures/deptime_sunset_id.pdf", width=15, height=5)
```
# Plot all time departure difference from sunset
```{r}
sunset_dep_feb+sunset_dep_march + plot_layout(axes ='collect')

ggsave(file="~/ownCloud/PhDLife/P.hastatus/Thesis/Paper3/analysis/figures/deptime_sunset_all.pdf", height=5, width = 7)
```

### How does departure time difference related to moonlight intensity?

Now I look at how departure times relate to the moonlight intensity across the days in the different periods

```{r}
#install.packages("calendR")
library(calendR)

# check if its related to lunar cycles
moon_feb <- calendR(year= 2022,
        month = 2,
        lunar = TRUE,
        lunar.size = 10)

moon_march <- calendR(year= 2022,
                    month = 3,
                    lunar = TRUE,
                    lunar.size = 10)

library(devtools)

#install moonlit library from github repo
#install_github("msmielak/moonlit")

#load the moonlit library
library(moonlit)

#extinction coefficient at sea level
e=0.28

moonlight_feb <- calculateMoonlightIntensity(commu_feb_dep$location_lat, commu_feb_dep$location_long, commu_feb_dep$minTimeLocal, e)

moonlight_march <- calculateMoonlightIntensity(lat=9.397357, lon=-82.26253, commu_march_dep$minTimeLocal, e)

```

# Plot moonline intensity model and departures in February and March 

Moonlight intensity depends predominantly on two factors: the amount of light reaching
the atmosphere and how this light is subsequently refracted and absorbed (Austin et al. 1976; Krisciunas and Schaefer 1991). 
 The amount of light reaching the atmosphere depends on the brightness of the moon face and the distance between the earth and the moon. The proportion of the light reaching the earth’s surface depends on the altitude of the moon in the sky which affects atmospheric absorption and refraction, while the angle of incidence further affects illumination levels. 

Moonlight model provides relative values of moonlight illumination. Model output can therefore be interpreted as moonlight intensity standardised to the range of 0 to 1.

```{r}
library(scales)

# add columns of illumination and moonphase for feb
commu_feb_dep$illumination <- moonlight_feb$moonlightModel
commu_feb_dep$moonphase <- moonlight_feb$moonPhase

# function factory for secondary axis transforms
train_sec <- function(primary, secondary, na.rm = TRUE) {
  # thanks Henry Holm for including the na.rm argument!
  from <- range(secondary, na.rm = na.rm)
  to   <- range(primary, na.rm = na.rm)
  # forward transform for the data
  forward <- function(x) {
    rescale(x, from = from, to = to)
  }
  # reverse transform for the secondary axis
  reverse <- function(x) {
    rescale(x, from = to, to = from)
  }
  list(fwd = forward, rev = reverse)
}

# apply function to our data in feb 
secfeb <- with(commu_feb_dep, train_sec(as.numeric(timeSinceSunset), illumination))

# plot for feb
dep_ilu_feb <- ggplot(commu_feb_dep, aes(x=date))+
  geom_point(aes(y=as.numeric(timeSinceSunset)))+
  geom_smooth(aes(y=as.numeric(timeSinceSunset)), method = "gam")+
  geom_point(aes(y=secfeb$fwd(illumination), color="pink")) +
  geom_smooth(aes(y=secfeb$fwd(illumination), color="pink"), method = "gam")+
   scale_y_continuous(
    
    # Features of the first axis
    name = "departure time after sunset (min)",
    
    # Add a second axis and specify its features
    sec.axis = sec_axis(~secfeb$rev(.), name="moonlight intensity")
  ) + 
   guides(color="none")+
  theme_classic()

# add columns of illumination and moonphase for feb
commu_march_dep$illumination <- moonlight_march$moonlightModel
commu_march_dep$moonphase <- moonlight_march$moonPhase

# apply function to our data in feb 
secmarch <- with(commu_march_dep, train_sec(as.numeric(timeSinceSunset), illumination))
  
# plot for march
dep_ilu_march <- ggplot(commu_march_dep, aes(x=date))+
  geom_point(aes(y=as.numeric(timeSinceSunset)))+
  geom_smooth(aes(y=as.numeric(timeSinceSunset)), method = "gam")+
  geom_point(aes(y=secmarch$fwd(illumination), color="pink")) +
  geom_smooth(aes(y=secmarch$fwd(illumination), color="pink"), method = "gam")+
   scale_y_continuous(
    
    # Features of the first axis
    name = "departure time after sunset (min)",
    
    # Add a second axis and specify its features
    sec.axis = sec_axis(~secmarch$rev(.), name="moonlight intensity")
  ) + 
   guides(color="none")+
  theme_classic()

# plot february and march together
dep_ilu_feb+dep_ilu_march +plot_layout(axes = "collect_x")

ggsave(file="~/ownCloud/PhDLife/P.hastatus/Thesis/Paper3/analysis/figures/deptime_moonlight.pdf", height=5, width = 7)

```
# Plot with moon phase

```{r}
library(scales)

# function factory for secondary axis transforms
train_sec <- function(primary, secondary, na.rm = TRUE) {
  # thanks Henry Holm for including the na.rm argument!
  from <- range(secondary, na.rm = na.rm)
  to   <- range(primary, na.rm = na.rm)
  # forward transform for the data
  forward <- function(x) {
    rescale(x, from = from, to = to)
  }
  # reverse transform for the secondary axis
  reverse <- function(x) {
    rescale(x, from = to, to = from)
  }
  list(fwd = forward, rev = reverse)
}

# apply function to our data in feb 
secfeb_moon <- with(commu_feb_dep, train_sec(as.numeric(timeSinceSunset), moonphase))

# plot for feb
dep_moon_feb <- ggplot(commu_feb_dep, aes(x=date))+
  geom_point(aes(y=as.numeric(timeSinceSunset)))+
  geom_smooth(aes(y=as.numeric(timeSinceSunset)), method = "gam")+
  geom_point(aes(y=secfeb_moon$fwd(moonphase), color="pink")) +
  geom_smooth(aes(y=secfeb_moon$fwd(moonphase), color="pink"), method = "gam")+
   scale_y_continuous(
    
    # Features of the first axis
    name = "departure time after sunset (min)",
    
    # Add a second axis and specify its features
    sec.axis = sec_axis(~secfeb$rev(.), name="moon phase")
  ) + 
   guides(color="none")+
  theme_classic()



# apply function to our data in feb 
secmarch_moon <- with(commu_march_dep, train_sec(as.numeric(timeSinceSunset), moonphase))
  
# plot for march
dep_moon_march <- ggplot(commu_march_dep, aes(x=date))+
  geom_point(aes(y=as.numeric(timeSinceSunset)))+
  geom_smooth(aes(y=as.numeric(timeSinceSunset)), method = "gam")+
  geom_point(aes(y=secmarch_moon$fwd(moonphase), color="pink")) +
  geom_smooth(aes(y=secmarch_moon$fwd(moonphase), color="pink"), method = "gam")+
   scale_y_continuous(
    
    # Features of the first axis
    name = "departure time after sunset (min)",
    
    # Add a second axis and specify its features
    sec.axis = sec_axis(~secmarch$rev(.), name="moon phase")
  ) + 
   guides(color="none")+
  theme_classic()

dep_moon_feb+dep_moon_march +plot_layout(axes = "collect_x")

ggsave(file="~/ownCloud/PhDLife/P.hastatus/Thesis/Paper3/analysis/figures/deptime_moonphase.pdf", height=5, width = 7)

```

### Plot moon intensity vs departures

```{r}
# join two data frames to plot departures in both dry periods
commu_feb_dep <- commu_feb_dep[order(commu_feb_dep$tag_local_identifier, commu_feb_dep$date),]
commu_feb_ret <- commu_feb_ret[order(commu_feb_ret$tag_local_identifier, commu_feb_ret$date),]

commu_feb_dep$timestamps_r <- commu_feb_ret$timestamps

commu_march_dep$year_cave <- "2022_dry-2"
commu_march_dep$timestamps <- commu_march_dep$departure_start
commu_march_dep$timestamps_r <- commu_march_dep$return_stop

#join data frame only for February and March
deps <- rbind(commu_feb_dep[,c("tag_local_identifier","timestamps","timestamps_r","date","timeSinceSunset","illumination", "moonphase", "year_cave")], commu_march_dep[,c("tag_local_identifier","timestamps" ,"timestamps_r","date","timeSinceSunset", "illumination", "moonphase", "year_cave")])

write.csv(deps, file="/Users/ccalderon/ownCloud/PhDLife/P.hastatus/Thesis/Paper3/data/departures_febmarch_illumination.csv")

# join data frames for all tracking periods
deps_all <- rbind(commu_feb_dep[,c("tag_local_identifier","timestamps","date","timeSinceSunset", "year_cave")], commu_march_dep[,c("tag_local_identifier","timestamps" ,"date","timeSinceSunset", "year_cave")], commu_2023_dep[,c("tag_local_identifier","timestamps" ,"date","timeSinceSunset",  "year_cave")])


write.csv(deps_all, file="/Users/ccalderon/ownCloud/PhDLife/P.hastatus/Thesis/Paper3/data/departures_febmarch_wetseason.csv")
```

### Plot departures vs illumination

Theere might be some relationship between moon light intesity and departure times. That we will test in script 10.

```{r}

dep_vs_ilu <- ggplot(aes(x=illumination,y=timeSinceSunset), data=deps)+
  geom_point(aes(color=as.factor(year_cave)))+
  geom_smooth(method = "lm")+
  ylab("Departure time after sunset (min)")+
  xlab("Illumination")+
  theme_classic()
dep_vs_ilu 
```

### Plot in a different way - departures vs illumination

```{r}
ilu <- ggplot(aes(x=date,y=illumination), data=deps)+
  geom_point()+
  ylab("Moon intensity")+
  xlab("Date")+
  geom_smooth(method = "gam")+
  theme_classic()

dep <- ggplot(aes(x=date,y=timeSinceSunset), data=deps)+
  geom_point()+
  ylab("Departure time after sunset (min)")+
  xlab("Date")+
  geom_smooth(method = "gam", color="#CC79A7")+
  theme_classic()

ilu / dep + plot_layout(axes="collect_x")

ggsave(file="/Users/ccalderon/ownCloud/PhDLife/P.hastatus/Thesis/Paper3/analysis/figures/dep_ilu_febmarch.pdf")

# apply function to our data in feb 
sec_ilu <- with(deps, train_sec(as.numeric(timeSinceSunset), illumination))

#plot for feb
dep_ilu_all <- ggplot(deps, aes(x=date))+
  geom_point(aes(y=as.numeric(timeSinceSunset)))+
  geom_smooth(aes(y=as.numeric(timeSinceSunset)), method = "gam")+
  geom_point(aes(y=sec_ilu$fwd(illumination), color="pink")) +
  geom_smooth(aes(y=sec_ilu$fwd(illumination), color="pink"), method = "gam")+
   scale_y_continuous(
    
    # Features of the first axis
    name = "Departure time after sunset (min)",
    
    # Add a second axis and specify its features
    sec.axis = sec_axis(~secfeb$rev(.), name="Moon intensity")
  ) + 
   guides(color="none")+
  xlab("Date")+
  theme_classic()
dep_ilu_all 
```
